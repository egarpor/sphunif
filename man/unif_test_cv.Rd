% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unif_test_cv.R
\docType{data}
\name{unif_test_cv}
\alias{unif_test_cv}
\alias{null_var}
\alias{avail_cir_cv_tests}
\alias{avail_sph_cv_tests}
\title{Circular and (hyper)spherical uniformity K-fold tests}
\format{
An object of class \code{character} of length 2.

An object of class \code{character} of length 3.
}
\usage{
unif_test_cv(data, type = "all", K = 10, p_value = "asymp",
  alpha = c(0.1, 0.05, 0.01), M = 10000, stats_MC = NULL,
  K_max = 10000, method = "I", null_variance = NULL, rel.tol = 1e-10,
  Poisson_rho = seq(0.1, 0.9, 0.1), Softmax_kappa = seq(0.1, 20, 1),
  Stereo_a = seq(-1, 1, 0.25), seed_fold = NULL, ...)

null_var(n, p, type, lambda_grid, rel.tol = 1e-10)

avail_cir_cv_tests

avail_sph_cv_tests
}
\arguments{
\item{data}{sample to perform the test. A matrix of size \code{c(n, p)}
containing a sample of size \code{n} of directions (in Cartesian
coordinates) on \eqn{S^{p-1}}. Alternatively if \code{p = 2}, a matrix of
size \code{c(n, 1)} containing the \code{n} angles on \eqn{[0, 2\pi)} of the
circular sample on \eqn{S^{1}}. Other objects accepted are an array of size
\code{c(n, p, 1)} with directions (in Cartesian coordinates), or a vector of
size \code{n} or an array of size \code{c(n, 1, 1)} with angular data.
Must not contain \code{NA}'s.}

\item{type}{type of test to be applied. A character vector containing any of
the following types of tests, depending on the dimension \eqn{p}:
\itemize{
  \item Circular data: any of the names available at object
  \code{\link{avail_cir_cv_tests}}.
  \item (Hyper)spherical data: any of the names available at object
  \code{\link{avail_sph_cv_tests}}.
}
If \code{type = "all"} (default), then \code{type} is set as
\code{avail_cir_cv_tests} or \code{avail_sph_cv_tests}, depending on the
value of \eqn{p}.}

\item{K}{Number of folds of (roughly) equal sizes to split \code{data}.}

\item{p_value}{type of \eqn{p}-value computation. Either \code{"MC"} for
employing the approximation by Monte Carlo of the exact null distribution or
\code{"asymp"} (default) for the use of the asymptotic null distribution
 (if available).}

\item{alpha}{vector with significance levels. Defaults to
\code{c(0.10, 0.05, 0.01)}.}

\item{M}{number of Monte Carlo replications for approximating the null
distribution when \code{approx = "MC"}. Also, number of Monte Carlo samples
for approximating the asymptotic distributions based on weighted sums of chi
squared random variables. Defaults to \code{1e4}.}

\item{stats_MC}{a data frame of size \code{c(M, length(type))}, with column
names containing the character vector \code{type}, that results from
extracting \code{$stats_MC} from a call to \code{\link{unif_stat_MC}}. If
provided, the computation of Monte Carlo statistics when \code{approx = "MC"}
is skipped. \code{stats_MC} is checked internally to see if it is sorted.
Internally computed if \code{NULL} (default).}

\item{K_max}{integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to \code{1e4}.}

\item{method}{method for approximating the density, distribution, or
quantile function of the weighted sum of chi squared random variables. Must
be \code{"I"} (Imhof), \code{"SW"} (Satterthwaite--Welch), \code{"HBE"}
(Hall--Buckley--Eagleson), or \code{"MC"} (Monte Carlo; only for distribution
or quantile functions). Defaults to \code{"I"}.}

\item{null_variance}{list of length \code{length(type)} and names equal
to \code{type} that contains the null variance values returned by
\code{null_var()} for the required grid of parameters. If \code{NULL}
(default), it is computed internally.}

\item{rel.tol}{TODO}

\item{Poisson_rho}{\eqn{\rho} parameter for the Poisson test, a real in
\eqn{[0, 1)}. Defaults to \code{0.5}.}

\item{Softmax_kappa}{\eqn{\kappa} parameter for the Softmax test, a
non-negative real. Defaults to \code{1}.}

\item{Stereo_a}{\eqn{a} parameter for the Stereo test, a real in
\eqn{[-1, 1]}. Defaults to \code{0}.}

\item{seed_fold}{an integer that fixes the seed for splitting data into
\code{K} folds.}

\item{...}{If \code{p_value = "MC"}, optional performance parameters to
be passed to \code{\link{unif_stat_MC}}: \code{chunks},
\code{cores}, and \code{seed}.}

\item{n}{sample size employed for computing the statistic.}

\item{p}{integer giving the dimension of the ambient space \eqn{R^p} that
contains \eqn{S^{p-1}}.}

\item{lambda_grid}{vector with parameters to compute null variance of the
statistic}
}
\value{
If only a \bold{single test} is performed, a list with class
\code{htest} containing the following components:
\itemize{
  \item \code{fold_statistics}: the value of the test statistic for
  each fold.
  \item \code{fold_params}: the value of the optimal parameter for
  each fold.
  \item \code{fold_p.values}: the p-values of the test for each fold.
  \item \code{p.value}: the HMP-aggregated p-value of the test.
  \item \code{alternative}: a character string describing the alternative
  hypothesis.
  \item \code{method}: a character string indicating what type of test was
  performed.
  \item \code{data.name}: a character string giving the name of the data.
  \item \code{reject}: the rejection decision for the levels of significance
  \code{alpha}.
}
If \bold{several tests} are performed, a \code{type}-named list with
entries for each test given by the above list.

\code{null_var} returns a vector of length \code{length(lambda_grid)}
that contains the values of the exact-n variance of the statistic
\code{type} under the null hypothesis.
}
\description{
Implementation of parameter-dependent uniformity tests
on the (hyper)sphere \eqn{S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}}{
S^{p-1}:=\{x\in R^p:||x||=1\}}, \eqn{p\ge 2} following the \eqn{K}-fold
cross-validation procedure, with asymptotically-exact Harmonic Mean P-value
calibration either in terms of their asymptotic distributions, if available,
or Monte Carlo.

\code{unif_test_cv} receives a sample of directions
\eqn{{\bf X}_1,\ldots,{\bf X}_n\in S^{p-1}}{X_1,\ldots,X_n\in S^{p-1}} in
\emph{Cartesian coordinates}, except for the circular case (\eqn{p=2}) in
which the sample can be represented in terms of \emph{angles}
\eqn{\Theta_1,\ldots,\Theta_n\in [0, 2\pi)}.

\code{unif_test_cv} allows to perform several tests within a single call,
facilitating thus the exploration of a dataset by applying several tests.

\code{unif_test_cv} needs a grid of parameters to find the one that maximizes
the power proxy. The grids are specified for each statistic parameter.

\code{null_var} computes the exact-\code{n} variance of the statistic for
a set of parameters \code{lambda_grid}.
}
\details{
All the tests reject for large values of the test statistic, so the critical
values for the significance levels \code{alpha} correspond to the
\code{alpha}-upper quantiles of the null distribution of the test statistic.

When \code{p_value = "asymp"}, tests that do not have an implemented or
known asymptotic are omitted, and a warning is generated.

When \code{p_value = "MC"}, it is possible to have a progress bar indicating
the Monte Carlo simulation progress if \code{unif_test} is wrapped with
\code{\link[progressr:with_progress]{progressr::with_progress}} or if
\code{progressr::handlers(global = TRUE)} is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.

Description of the \eqn{K}-fold cross-validation procedure is available
in Fernández-de-Marcos and García-Portugués (2023).
Descriptions and references for most of the tests are available
in García-Portugués and Verdebout (2018).
}
\examples{
## Asymptotic distribution

seed <- 12345

# Circular data
n <- 50
samp_cir <- r_unif_cir(n = n)

# Matrix
unif_test_cv(data = samp_cir, type = "all", K = 3, p_value = "asymp",
             seed_fold = seed)

# Vector
unif_test_cv(data = samp_cir[, 1], type = "all", K = 3, p_value = "asymp",
             seed_fold = seed)

# Array
unif_test_cv(data = array(samp_cir, dim = c(n, 1, 1)), type = "all", K = 3,
             p_value = "asymp", seed_fold = seed)

# Spherical data
n <- 50
samp_sph <- r_unif_sph(n = n, p = 3)

# Array
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
             p_value = "asymp", seed_fold = seed)

# Matrix
unif_test_cv(data = samp_sph[, , 1], type = c("Poisson", "Softmax"), K = 3,
             p_value = "asymp", seed_fold = seed)

## Monte Carlo

# Circular data
unif_test_cv(data = samp_cir, type = "all", K = 3, p_value = "MC", M = 1e3,
             seed_fold = seed)

# Spherical data
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3, M = 1e3,
             p_value = "MC", seed_fold = seed)

# Caching stats_MC
stats_MC_cir <- unif_stat_MC(n = nrow(samp_cir), type = avail_cir_cv_tests,
                             p = 2, M = 1e3, r_H1 = NULL, crit_val = NULL,
                             return_stats = TRUE, stats_sorted = TRUE,
                             Poisson_rho = seq(0.1, 0.9, 0.1),
                             Softmax_kappa = seq(0.1, 20, 1),
                             Stereo_a = seq(-1, 1, 0.25))$stats_MC
stats_MC_sph <- unif_stat_MC(n = nrow(samp_sph), type = avail_sph_cv_tests,
                             p = 3, M = 1e3, r_H1 = NULL, crit_val = NULL,
                             return_stats = TRUE, stats_sorted = TRUE,
                             Poisson_rho = seq(0.1, 0.9, 0.1),
                             Softmax_kappa = seq(0.1, 20, 1),
                             Stereo_a = seq(-1, 1, 0.25))$stats_MC
unif_test_cv(data = samp_cir, type = avail_cir_tests, K = 3, p_value = "MC",
             stats_MC = stats_MC_cir, seed_fold = seed)
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
             p_value = "MC", stats_MC = stats_MC_sph, seed_fold = seed)

## Using a progress bar when p_value = "MC"

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = ":spin [:bar] :percent Total: :elapsedfull End \u2248 :eta",
  clear = FALSE))

# Call unif_test() within with_progress()
with_progress(
  unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
               p_value = "MC", , M = 1e3, seed_fold = seed, chunks = 10)
)
}
\references{
Fernández-de-Marcos, A. and García-Portugués, E. (2023) On new omnibus tests
of uniformity on the hypersphere. \emph{Test}, 32(4):1508-–1529.
\doi{10.1007/s11749-023-00882-x}

García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. \emph{arXiv:1804.00286}.
\url{https://arxiv.org/abs/1804.00286}.
}
\keyword{datasets}
