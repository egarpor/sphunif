% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unif_test_cv.R
\docType{data}
\name{unif_test_cv}
\alias{unif_test_cv}
\alias{lambda_hat}
\alias{k_fold_stat}
\alias{p_val_hmp}
\alias{k_fold_split}
\alias{prepare_test_data}
\alias{avail_cir_cv_tests}
\alias{avail_sph_cv_tests}
\title{Circular and (hyper)spherical uniformity K-fold tests}
\format{
An object of class \code{character} of length 2.

An object of class \code{character} of length 3.
}
\usage{
lambda_hat(data, type, lambda_grid, folds, K_max = 1000,
  null_variance = NULL, verbose = TRUE)

k_fold_stat(data, type, lambda_grid, folds = NULL, K = NULL, seed = NULL,
  K_max = 1000, null_variance = NULL, verbose = TRUE)

p_val_hmp(p_vals, M)

unif_test_cv(data, type, K, p_value = "asymp", alpha = c(0.1, 0.05, 0.01),
  M = 10000, stats_MC = NULL, K_max = 10000, method = "I",
  null_variance = NULL, Poisson_rho = seq(0.1, 0.9, 0.1),
  Softmax_kappa = c(0.1, seq(1, 5, 1), seq(10, 30, 5)), Stereo_a = seq(-1,
  1, 0.25), seed_fold = NULL, verbose = TRUE, ...)

k_fold_split(n, K, seed = NULL)

prepare_test_data(data)

avail_cir_cv_tests

avail_sph_cv_tests
}
\arguments{
\item{data}{sample to perform the test. A matrix of size \code{c(n, p)}
containing a sample of size \code{n} of directions (in Cartesian
coordinates) on \eqn{S^{p-1}}. Alternatively if \code{p = 2}, a matrix of
size \code{c(n, 1)} containing the \code{n} angles on \eqn{[0, 2\pi)} of the
circular sample on \eqn{S^{1}}. Other objects accepted are an array of size
\code{c(n, p, 1)} with directions (in Cartesian coordinates), or a vector of
size \code{n} or an array of size \code{c(n, 1, 1)} with angular data.
Must not contain \code{NA}'s.}

\item{type}{type of test to be applied. A character vector or a single string
 containing any of the following types of tests, depending on the dimension
 \eqn{p}:
\itemize{
  \item Circular data: any of the names available at object
  \code{\link{avail_cir_cv_tests}}.
  \item (Hyper)spherical data: any of the names available at object
  \code{\link{avail_sph_cv_tests}}.
}
In \code{unif_test_cv}, if \code{type = "all"} (default), then \code{type}
is set as \code{avail_cir_cv_tests} or \code{avail_sph_cv_tests}, depending
on the value of \eqn{p}.}

\item{lambda_grid}{list of size \code{length(type)} and names equal to
\code{type} with a vector of parameters to compute the optimal
\code{lambda_hat} (see \code{Poisson_rho}, \code{Softmax_kappa},
or \code{Stereo_a} for additional requirements).}

\item{folds}{list of length \code{K}, each element containing a vector with
the indexes of observations included in each fold, as returned by a call
to \code{k_fold_split}. Optional in \code{k_fold_stat}, defaults to
\code{NULL}. If \code{NULL}, folds are computed internally calling
\code{k_fold_split}, but \code{K} must be specified.}

\item{K_max}{integer giving the truncation of the series that compute the
asymptotic p-value of a Sobolev test. Defaults to \code{1e3}.}

\item{null_variance}{list of length \code{length(type)} and names equal
to \code{type} that contains the null variance values returned by
\code{null_var_Sobolev()} for the required grid of parameters. If \code{NULL}
(default), it is computed internally.}

\item{verbose}{output information about the truncation? Defaults to
\code{TRUE}.}

\item{K}{Number of folds of (roughly) equal sizes to split \code{data}.}

\item{p_vals}{matrix of size \code{K x length(type)} containing p_values
computed for each \code{K} fold and test in \code{type}.}

\item{M}{number of Monte Carlo replications for approximating the null
distribution when \code{approx = "MC"}. Also, number of Monte Carlo samples
for approximating the asymptotic distributions based on weighted sums of chi
squared random variables. Defaults to \code{1e4}.}

\item{p_value}{type of \eqn{p}-value computation. Either \code{"MC"} for
employing the approximation by Monte Carlo of the exact null distribution or
\code{"asymp"} (default) for the use of the asymptotic null distribution
 (if available).}

\item{alpha}{vector with significance levels. Defaults to
\code{c(0.10, 0.05, 0.01)}.}

\item{stats_MC}{a data frame of size \code{c(M, length(type))}, with column
names containing the character vector \code{type}, that results from
extracting \code{$stats_MC} from a call to \code{\link{unif_stat_MC}}. If
provided, the computation of Monte Carlo statistics when \code{approx = "MC"}
is skipped. \code{stats_MC} is checked internally to see if it is sorted.
Internally computed if \code{NULL} (default).}

\item{method}{method for approximating the density, distribution, or
quantile function of the weighted sum of chi squared random variables. Must
be \code{"I"} (Imhof), \code{"SW"} (Satterthwaite--Welch), \code{"HBE"}
(Hall--Buckley--Eagleson), or \code{"MC"} (Monte Carlo; only for distribution
or quantile functions). Defaults to \code{"I"}.}

\item{Poisson_rho}{\eqn{\rho} parameter for the Poisson test, a real in
\eqn{[0, 1)}. Defaults to \code{0.5}.}

\item{Softmax_kappa}{\eqn{\kappa} parameter for the Softmax test, a
non-negative real. Defaults to \code{1}.}

\item{Stereo_a}{\eqn{a} parameter for the Stereo test, a real in
\eqn{[-1, 1]}. Defaults to \code{0}.}

\item{seed_fold}{an integer that fixes the seed for splitting data into
\code{K} folds. It also applies to \code{seed} in \code{k_fold_split()} and
\code{k_fold_stat()}.}

\item{...}{If \code{p_value = "MC"}, optional performance parameters to
be passed to \code{\link{unif_stat_MC}}: \code{chunks},
\code{cores}, and \code{seed}.}

\item{n}{sample size.}
}
\value{
\code{unif_test_cv}: If only a \bold{single test} is performed, a
list with class \code{htest} containing the following components:
\itemize{
  \item \code{fold_statistics}: the value of the test statistic for
  each fold, a vector of length \code{K}.
  \item \code{fold_params}: the value of the optimal parameter for
  each fold, a vector of length \code{K}.
  \item \code{fold_p.values}: the p-values of the test for each fold, a
  vector of length \code{K}.
  \item \code{p.value}: the HMP-aggregated p-value of the test.
  \item \code{alternative}: a character string describing the alternative
  hypothesis.
  \item \code{method}: a character string indicating what type of test was
  performed.
  \item \code{data.name}: a character string giving the name of the data.
  \item \code{reject}: the rejection decision for the levels of significance
  \code{alpha}.
}
If \bold{several tests} are performed, a \code{type}-named list with
entries for each test given by the above list.

Intermediate functions return:
\itemize{
  \item \code{lambda_hat}: a matrix of size \code{K x length(type)}
  containing the optimal parameters for each of the \code{K} folds.
  \item \code{k_fold_stat}: a named list with \code{statistic} and
  \code{lambda_hat} with a data.frame and a matrix, respectively,
  of size \code{K x length(type)} containing the statistic and the optimal
  parameters for each of the \code{K} folds.
  \item \code{p_val_hmp}: a matrix of size \code{K x length(type)}
  containing the aggregated Harmonic Mean P-value for each test in
  \code{type}.
  \item \code{k_fold_split}: a list of length \code{K}, each element
  containing a vector with the indexes of observations included in each fold.
  \item \code{prepare_test_data}: a named list containing the processed data
  for testing uniformity in \code{data}, the sample size in \code{n}, the
  ambient dimension in \code{p}, and a list of the available CV tests
  depending on \code{p} in \code{avail_stats}.
}
}
\description{
Implementation of parameter-dependent uniformity tests
on the (hyper)sphere \eqn{S^{p-1}:=\{{\bf x}\in R^p:||{\bf x}||=1\}}{
S^{p-1}:=\{x\in R^p:||x||=1\}}, \eqn{p\ge 2} following the \eqn{K}-fold
cross-validation procedure, with asymptotically-exact Harmonic Mean P-value
calibration either in terms of their asymptotic distributions, if available,
or Monte Carlo.

\code{unif_test_cv} receives a sample of directions
\eqn{{\bf X}_1,\ldots,{\bf X}_n\in S^{p-1}}{X_1,\ldots,X_n\in S^{p-1}} in
\emph{Cartesian coordinates}, except for the circular case (\eqn{p=2}) in
which the sample can be represented in terms of \emph{angles}
\eqn{\Theta_1,\ldots,\Theta_n\in [0, 2\pi)}.

\code{unif_test_cv} allows to perform several tests within a single call,
facilitating thus the exploration of a dataset by applying several tests.

\code{unif_test_cv} needs a grid of parameters to find the one that maximizes
the power proxy. The grids are specified for each test statistic parameter.

\code{avail_cir_cv_tests} and \code{avail_sph_cv_tests} are character vectors
whose elements are valid inputs for the \code{type} argument in
\code{unif_test_cv}, \code{k_fold_stat}, and \code{lambda_hat}.
\code{*_cir_*} provides circular \eqn{K}-fold tests and \code{*_sph_*}
the (hyper)spherical \eqn{K}-fold tests.
}
\details{
All the tests reject for large values of the test statistic, so the critical
values for the significance levels \code{alpha} correspond to the
\code{alpha}-upper quantiles of the null distribution of the test statistic.

When \code{p_value = "asymp"}, tests that do not have an implemented or
known asymptotic are omitted, and a warning is generated.

When \code{p_value = "MC"}, it is possible to have a progress bar indicating
the Monte Carlo simulation progress if \code{unif_test} is wrapped with
\code{\link[progressr:with_progress]{progressr::with_progress}} or if
\code{progressr::handlers(global = TRUE)} is invoked (once) by the user.
See the examples below. The progress bar is updated with the number of
finished chunks.

Description of the \eqn{K}-fold cross-validation procedure is available
in Fernández-de-Marcos and García-Portugués (2023). Descriptions and
references for most of the tests are available in
García-Portugués and Verdebout (2018).
}
\examples{
## Asymptotic distribution

seed <- 12345

# Circular data
n <- 50
samp_cir <- r_unif_cir(n = n)

# Matrix
unif_test_cv(data = samp_cir, type = "all", K = 3, p_value = "asymp",
             seed_fold = seed, K_max = 1e3, verbose = FALSE)

# Vector
unif_test_cv(data = samp_cir[, 1], type = "all", K = 3, p_value = "asymp",
             seed_fold = seed, K_max = 1e3, verbose = FALSE)

# Array
unif_test_cv(data = array(samp_cir, dim = c(n, 1, 1)), type = "all", K = 3,
             p_value = "asymp", seed_fold = seed, K_max = 1e3,
             verbose = FALSE)

# Spherical data
n <- 50
samp_sph <- r_unif_sph(n = n, p = 3)

# Array
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
             p_value = "asymp", seed_fold = seed, K_max = 1e3,
             verbose = FALSE)

# Matrix
unif_test_cv(data = samp_sph[, , 1], type = c("Poisson", "Softmax"), K = 3,
             p_value = "asymp", seed_fold = seed, K_max = 1e3,
             verbose = FALSE)

## Monte Carlo

# Circular data
unif_test_cv(data = samp_cir, type = "all", K = 3, p_value = "MC", M = 1e3,
             seed_fold = seed, K_max = 1e3, verbose = FALSE)

# Spherical data
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3, M = 1e3,
             p_value = "MC", seed_fold = seed, K_max = 1e3, verbose = FALSE)

# Caching stats_MC
stats_MC_cir <- unif_stat_MC(n = nrow(samp_cir), type = avail_cir_cv_tests,
                             p = 2, M = 1e3, r_H1 = NULL, crit_val = NULL,
                             return_stats = TRUE, stats_sorted = TRUE,
                             Poisson_rho = seq(0.1, 0.9, 0.1),
                             Softmax_kappa = seq(0.1, 20, 1),
                             Stereo_a = seq(-1, 1, 0.25))$stats_MC
stats_MC_sph <- unif_stat_MC(n = nrow(samp_sph), type = avail_sph_cv_tests,
                             p = 3, M = 1e3, r_H1 = NULL, crit_val = NULL,
                             return_stats = TRUE, stats_sorted = TRUE,
                             Poisson_rho = seq(0.1, 0.9, 0.1),
                             Softmax_kappa = seq(0.1, 20, 1),
                             Stereo_a = seq(-1, 1, 0.25))$stats_MC
unif_test_cv(data = samp_cir, type = avail_cir_tests, K = 3, p_value = "MC",
             stats_MC = stats_MC_cir, seed_fold = seed, K_max = 1e3,
             verbose = FALSE)
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
             p_value = "MC", stats_MC = stats_MC_sph, seed_fold = seed,
             K_max = 1e3, verbose = FALSE)

## Pre-specifying null_variance
Poisson_grid <- c(0.1, 0.5, 0.7)
Softmax_grid <- c(0.1, 0.5, 1, 5, 10)
null_variance <- sapply(c("Poisson", "Softmax"), function(stat_type) {

  lambda_grid <- switch(stat_type,
                        "Poisson" = Poisson_grid,
                        "Softmax" = Softmax_grid)

  return(null_var_Sobolev(n = round(n / 3), p = 3, type = stat_type,
                  lambda_grid = lambda_grid, verbose = FALSE))

})
unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
             p_value = "MC", M = 1e3, null_variance = null_variance,
             seed_fold = seed, Poisson_rho = Poisson_grid,
             Softmax_kappa = Softmax_grid, K_max = 1e3, verbose = FALSE)

## Using a progress bar when p_value = "MC"

# Define a progress bar
require(progress)
require(progressr)
handlers(handler_progress(
  format = ":spin [:bar] :percent Total: :elapsedfull End \u2248 :eta",
  clear = FALSE))

# Call unif_test() within with_progress()
with_progress(
  unif_test_cv(data = samp_sph, type = c("Poisson", "Softmax"), K = 3,
               p_value = "MC", , M = 1e3, seed_fold = seed,
               K_max = 1e3, verbose = FALSE, chunks = 10)
)
}
\references{
Fernández-de-Marcos, A. and García-Portugués, E. (2023) On new omnibus tests
of uniformity on the hypersphere. \emph{Test}, 32(4):1508-–1529.
\doi{10.1007/s11749-023-00882-x}

García-Portugués, E. and Verdebout, T. (2018) An overview of uniformity
tests on the hypersphere. \emph{arXiv:1804.00286}.
\doi{10.48550/arXiv.1804.00286}.
}
\keyword{datasets}
\keyword{internal}
